# 数据和C

**程序离不开数据。%%把数字、字母和文字输入计算机，就是希望它利用这些数据完成某些任务。%%**

通过printf、scanf 可以建立人机双向通信。

``` C
scanf("%f", $weigsht)
```
> &：表明找到变量的地点，把输入的值赋给该变量

**变量（variable）：数据在程序运行期间可能会改变或被赋值；**
> 在声明时指定其类型

**常量（constant）：数据在程序使用前被设定，始终不会改变。**
> 编译器通过用户书写的形式来识别类型


C 语言有多种数据类型，让程序员针对不同情况选择不同的类型。
数据类型（按计算机存储方式分）
+ 整数：short、int、char、\_Bool
	+ long：long int、long long int
	+ unsigned: unsigned int、unsigned char
+ 浮点数：float、double

一般而言，系统用一个特殊位的值表示有符号整数的正负号。

## 整数

### int

int：有符号整型

==默认情况下，编译器假定整型常量是int。==

转换说明
+ 进制
	+ 十进制：%d（int）
	+ 八进制：%o
	+ 十六进制：%x
> X ：进制对应字母大写
> %#o、%#x：显示前缀
+ 类型
	+ int：%d（十进制）
	+ short：%hd、%hu、%#hX、%hx、%#hx
	+ long：%ld、%lu、%lo

``` C
printf("short hex %#hX", 10);
```

八进制和十六进制常量被视为int 类型。

字面常量指定非int
+ long：添加小写L 或大写L `1000L`
+ unsigned：添加小写U 或大写U `1000LU, 1000Lu`

新类型
+ C90：unsigned long、unsigned short
+ C99：unsigned long long

依计算机的自然字长而定，在实际使用中，有些类型之间通常有重叠。C 标准对基本数据类型只规定了允许的最小大小。

==unsigned 类型的数常用于计数，因为计数不用负数。==

### char

char 类型用于存储字符。
根据C90 标准，允许在关键字char 前面使用signed 或unsigned。

**C 语言中用单引号括起来的单个字符被称为字符常量（character constant）。**
``` C
char grade = 'A';
```

字符是以数值形式存储的，所以也可使用数字代码值来赋值。
``` C
char grade = 65;
```

char 可用%d 打印整数，或%c 打印字符。
```
printf("code: %d, character: %c", 65, 65);
```

### \_Bool

C99 标准添加了_Bool 类型，用于表示布尔值。
C语言用值1表示true，值0表示false。原则上仅占用1位空间。

## 浮点数

浮点数：小数部分 + 指数部分

C 标准规定，==float 类型必须至少能表示6位有效数字==，且取值范围至少是$10^{-37}～10^{37}$。double 类型的值至少有13位有效数字。

==默认情况下，编译器假定浮点型常量是double。==
> 添加f 或F 后缀得到float
> 添加l 或L 后缀得到long double

浮点数字面量书写形式
1. `0.5`
2. `.5`
3. `5e-1`
4. `5.`

转换说明
+ %f：double 或float
	+ %Lf：long double
+ %e：科学计数法
	+ %Le：long double 科学计数法
+ %g：自动选择%f 或%e
``` C
printf("%.2e", 100.);
```

溢出
+ 上溢（overflow）
+ 下溢（underflow）

C 语言把损失了类型全精度的浮点值称为低于正常的（subnormal）浮点值。

特殊的浮点值NaN（not a number）。

## 使用数据类型

sizeof 是C 语言的内置运算符，**以字节为单位**给出指定类型的大小。
C99 和C11 提供%zd转换说明匹配sizeof 的返回类型。一些不支持的可用%u 或%lu代 替%zd。
> %zd、%zx、%zX……

``` C
int x = 1;
```

初始化变量应使用与变量类型匹配的常数类型。

把一个类型的数值初始化给不同类型的变量时，编译器会把值转换成与变量匹配的类型，这将导致部分数据丢失。
> 把浮点数转换成整数时，会直接截断小数部分，只保证了float 类型前6位的精度。

# 字符串和格式化输入输出

## 字符串

字符串（character string）：一个或多个字符的序列。

字符串和字符的区别

- 字符的类型char，字符串是char 数组（派生类型）
- 字符串末尾会比字符多一个空字符\0

``` C
char name[40];
```
字符串被存储在char 类型的数组中，字符串末尾必有\\0（空字符，null character）。
> \\0 用于标记字符串结束，scanf() 以及字符串常量会自动添加。

strlen()：给出字符串长度，空字符不纳入其中。

## 常量

使用常量的优点
+ 常量名能表达更多的信息
+ 统一管理出现多次的数字

定义常量的方法
+ 明示常量（manifest constant）：`#define PI 3.14`
+ 只读变量：`float const PI = 3.14;`

编译时替换（compile-time substitution）：编译时，所有出现在程序中预处理器定义的常量名，都会用定义项原封不动的取代。

常量命名规则
+ 一贯传统大写 `LEVEL`
+ 偶尔用c_ 前缀 `c_level`

每个头文件都会定义一系列明示常量
+ limits.h：整型的表示范围等信息
+ float.h：浮点有效数字位等信息

## printf 和scanf

### printf

printf 打印修饰
+ -：左对齐 `"%-5d"`
+ +：显示正负 `"%+d"`
+ \#：添加前缀 `"%#X"`
+ 0：添加前导 `"%02d"`
+ \*：动态宽精 `%*d`

printf 断行方法
+ 同一输出用多printf()
+ 字符串内反斜杠断行
+ 不同行的多段字符串
	``` C
	printf("long");
	printf("string.\n");

	printf("Here's another way to print a \
	long string.\n");

	printf(
		"Here's the newest way to print a"
		"long string.\n" // ANSI C
	);
	```

printf 原理
1. 将值读入栈（stack）的内存区域
2. 根据转换说明依次从栈中读取值

print 技巧：**在两个转换说明中间插入一个空白字符，可以确保即使一个数字溢出了自己的占位，也不会和下一个数字紧挨在仪器。**
> 因为格式字符串中的普通字符（包括空格）会被打印出来
``` C
printf("%2d %2d%2d", 1000, 2024, 800);
// 打印结果 1000 2024800
```

**输入” 等转移字符需要用反斜杠`\"`，输入% 需要双写`%%`**

只打印字符串的前几位 `%.\ds`
``` C
printf("%.2s", "Alice");
```

### scanf

==printf() 使用变量、常量和表达式，而scanf() 使用指向变量的指针。==
+ 如果用scanf()读取基本变量类型的值，变量前加上&
+ 如果用scanf()把字符串读入字符数组中，不要使用&

scanf() 使用空白（换行符、制表符和空格）把输入分成多个字段，匹配转换说明时跳过空白。
> 唯一例外的是%c。scanf() 会读取每个字符，包括空白。

scanf 转换说明
+ c: 字符
+ d: 有符号十进制整数
+ e、f、g、a（C99）；E、F、G、A：浮点数
+ i：有符号十进制整数
+ o：有符号八进制整数
+ p：指针（地址）
+ s：字符串
+ u：无符号十进制整数
+ x、X：有符号十六进制整数

scanf 修饰符
+ \*：抑制赋值
+ \\d：最大宽度

scanf 原理
+ 跳过头部的空白符
+ 读取转换说明相匹配的字符，不匹配则保存留待下次scanf

scanf() 允许把普通字符放在格式字符串中
+ 多个连续空白字符视作一个或零个
+ 其他字符必须严格匹配格式字符串
``` C
int n, m;
scanf("%d   ,%d", &n, &m);

// 适用情况
> 1,2
> 1  ,  2
> 1 ,2
> 1, 2
```

scanf() 返回成功读取的项数。
当scanf() 检测到“文件结尾”时，会返回EOF。
> EOF：stdio.h中定义的特殊值，通常用#define指令把EOF定义为-1

### \* 修饰符

在printf 中使用\* 修饰符来实现输入控制宽度和精度的效果。
``` C
unsigned width, precision;
double weight = 242.5;

printf("Enter a width and a precision:\n");
scanf("%d %d", &width, &precision);
printf("Weight = %*.*f\n", width, precision, weight);
```

在scanf 中使用\* 会跳过相应的输入项。
``` C
int n;
printf("Please enter three integers:\n");
scanf("%*d %*d %d", &n);
printf("The last integer was %d\n", n);
```

> 利用* 动态实现不同的对齐方式
``` C
int const c_width = 10;
int len_name, len_surname;
char name[20];
char surname[20];
scanf("%s %s", &name, &surname);
len_name = strlen(name);
len_surname = strlen(surname);
// align left
printf("%*s %*s\n", -c_width, name, -c_width, surname);
printf("%*d %*d\n", -c_width, len_name, -c_width, len_surname);
// align inner right
printf("%*s %*s\n", -c_width, name, -c_width, surname);
printf("%*d %*d\n",len_name, len_name, c_width - len_name + len_surname, len_surname);
```

# 运算符、表达式和语句

## 运算符概念

C 用运算符（operator）表示运算。

符号=被称为赋值运算符。
> `bmw = 2002;` 读作：把值2002赋给变量bmw 

可修改的左值（modifiable lvalue）：用于标识可修改的对象。
> 当前标准建议使用名称：对象定位值（object locator value）
> 当前标准建议右值（rvalue）使用名称：表达式的值（value of an expression）

运算对象（operand）：运算符操作的对象。

C 语言支持多重赋值
``` C
int jane, tarzan, cheeta;
cheeta = tarzan = jane = 68;
```

## 基本运算符

加法运算符（addition operator）

减法运算符（subtraction operator）

一元运算符（unary operator）

除法运算
+ 浮点数除法的结果是浮点数
+ 整数除法的结果是整数：整数除法会直接丢弃小数部分（截断，truncation）
> 对于负数，C99 规定使用趋零截断：$-3.8 \Rightarrow -3$
+ 整数和浮点数除法结果是浮点数：编译器会把运算对象转换成相同类型

运算符优先级（从高至低）
%%一元运算符结合律从右至左%%

| 运算符     | 结合律 |
| ------- | --- |
| ()      | →   |
| + -（一元） | ←   |
| * /     | →   |
| + -（二元） | →   |
| =       | ←   |
%%某些场合习惯用表达式树（expression tree）来表示求值顺序%%

## 其他运算符

### sizeof

<u>sizeof 运算符</u> 以字节为单位返回运算对象的大小
+ 运算一个对象，可以不加圆括号
+ ==运算一个类型，必须要加圆括号==
> ``` C
> int x = 2;
> printf("%zd %zd", sizeof x, sizeof(int));
> ```


C语言规定 sizeof 返回size_t 类型的值（无符号整数类型）。C99 新增%zd 以支持该类型，系统不支持%zd，则可使用%u 或%lu。
> 可以利用typedef 将size_t 取别名为unsigned int 或unsigned long，编译器就能根据不同的系统替换标准类型

### 求模运算符：%

求模运算符（modulus operator）：给出运算符左侧整数除以右侧整数的余数（remainder）
==求模运算只能用于整数==

C99 规定“趋零截短”后，负数求模的结果：
+ 第1个运算对象负数：负数
> 两个数都是负数：负数
+ 第2个运算对象正数：正数

### 递增递减运算符：++ --

一元运算
+ 递增运算符（increment operator）
+ 递减运算符（decrement operator）

出现位置
+ ==前缀模式 ++i：先计算，再取值==
+ ==后缀模式 i++：先取值，再计算==
> 先出现的，先计算

递增或递减运算可以使程序更简洁。
> 例如，使用递增运算可以将循环测试和循环更新集中在一起
> ``` C
> int i = 0;
> while (++i <= 10){
> 	printf("%-2d\n", i);
> }
> ```

遵循以下规则，以避免滥用递增、递减运算符导致计算出错
+ 在函数中多次出现的参数，不要使用
+ 表达式中多次出现的变量，不要使用

### 复合赋值运算符

+=，-=，\*=，/=……：结合了赋值操作和算数操作，优先级与赋值运算符相同。

## 表达式和语句

表达式（expression）：运算符和运算对象组成
+ 表达式可以包含表达式（子表达式，subexpression）
+ 每个表达式都有一个值

语句（statement）：C 程序的基本构建块。一条语句相当于一条完整的计算机指令，语句可以改变值或调用函数。
> 最简单语句是空语句（null statement）`;`
> 声明不是表达式语句

副作用（side effect）：对数据对象或文件的修改

序列点（sequence point）：程序执行的点，该点所有的副作用都在进入下一步之前发生。
+ 分号标记了一个序列点
+ 完整表达式的结束也是
> 完整表达式（full expression）：表达式不是另一个更大表达式的子表达式

复合语句（compound statement）：用花括号括起来的一条或多条语句
> 复合语句也称为块（block）

## 类型转换

[[编写高质量代码：改善C 程序代码的125个建议#建议4：数据类型转换必须做范围检查]]

## 带参函数

声明参数就创建了被称为形式参数（formal argument，形参）的变量。

函数调用传递的值为实际参数（actual argument，实参）。

# C 控制语句：循环

## 循环简介

**应该让计算机做一些重复计算的工作。毕竟，需要重复计算是使用计算机的主要原因。**

``` C
long num;
long sum = 0L;

printf("Please enter next integer: ");
while (scanf("%ld", &num)){
	sum = sum + num;
	printf("Please enter next integer: ");
}

printf("Those integers sum to %ld.\n", sum);
```

scanf 能返回读取成功的数量，副作用是给变量赋值。因此可用于循环测试和循环更新：
+ 不影响用户输入
+ 处理更简洁方便

使用伪代码（pseudocode）描述可以聚焦于程序的逻辑结构，而不关心实现细节。
``` C
/*
当获取值和判断值都成功
	处理该值
*/

while (scanf("%ld", &num) == 1)
	// 循环行为
```

只有一条语句时，可以不用花括号。
> ==缩进对编译器不起作用，缩进是为了让读者看出程序的逻辑结构。==

``` C
int num;
while (scanf("%d", &num)) ;
```
==紧接着循环入口条件后的空语句会被视为循环体，造成无限循环（infinite loop）==
> 为了提高代码可读性，应将空语句独占一行，或使用`continue`

不确定循环（indefinite loop）：在测试表达式为假之前，预先不知道要执行多少次循环。

计数循环（counting loop）：在执行循环之前就知道要重复执行多少次。
1. 必须初始化计数器
2. 计数器与有限的值比较
3. 每次循环时更新计数器

通常入口条件循环使用较多：for、while
1. 测试放在循环开头，可读性更好
2. 一般需要在测试条件为假时跳过

while 模拟for
```
初始化
while (测试条件){
	其他语句
	更新循环
}
```

for 模拟while
```
for(; 测试条件;)
	其他语句
```

嵌套循环（nested loop）：在一个循环内包含另一个循环
+ 外层循环（outer loop）
+ 内存循环（inner loop）

## 关系运算符

关系表达式（relational expression）
> 在C 中表达式一定有一个真值：**所有非0 都被视为真，0 为假**
> 关系表达式通常作为测试条件

关系运算符（relational operator）
+ 相等运算符（equality operator）：`==`
> **将待比较的常量放在左侧，能让编译器帮忙检测相等运算符是否误用为赋值运算符**
> ``` C
> 5 == x
> ```

比较浮点数时，尽量只是用大于、小于。因为**浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等。**
> 使用math.h/fabs() 函数可以比较浮点数：返回一个浮点值的绝对值
> ``` C
> fabs(float0 -float1) > .0001
> ```

### \_Bool

**C99 新增了_Bool 类型**
%%> 英国数学家George Boole 开发了用代数表示和解决逻辑问题%%

布尔变量（Boolean variable） ：只能存储1（真），0（假）；非0 会被设置为1。
> 通常给布尔变量取一个能表示真假的名字 `_Bool input_is_good;`

**C99 提供了stdbool.h 头文件，给\_Bool 取别名bool，并分别定义了true 和false 表示1和0。**
> bool、true 和false 可兼容C++
> 当系统不兼容布尔时用int 代替
``` C
#include <stdbool.h>
bool flag0 = True;
bool flag1 = 1;
```

### 运算符优先级

关系运算符结合律从左往右。优先级高于赋值运算符，低于算数运算符。
+ 高优先级：$< \ <= \ > \ > \ >=$
+ 低优先级：$== \ !=$

| 运算符（优先级从高至低）  | 结合律   |
| ------------- | ----- |
| ()            | →     |
| + - ++ --（一元） | ==←== |
| * / %         | →     |
| + -           | →     |
| <  >  <=  >=  | →     |
| ==  !=        | →     |
| =             | ==←== |

## while 循环

``` C
while(expression)
	statement
```
expression 为真（非零）时循环
> 每次循环都被称为一次迭代（iteration）

while 循环是使用入口条件的有条件循环。所谓“有条件”指的是语句部分的执行取决于测试表达式描述的条件。
> **入口条件（entry condition），必须满足条件才能进入循环体。**

## for 循环

for 语句是一种入口条件循环，即在执行循环之前就决定了是否执行循环。

``` C
for(initialize; test; update) // 表达式分号分隔
	statement
```
1. 初始化（赋初值）：只会在for循环开始时执行一次
2. 测试条件（计数范围）：在执行循环之前对表达式求值，为假时循环结束
3. 执行更新（更新计数）：在每次循环结束时求值

for 圆括号中的表达式也叫作控制表达式，它们都是完整表达式，所以每个表达式的副作用（如，递增变量）都发生在对下一个表达式求值之前。
> 圆括号中的表达式也叫作控制表达式，**它们都是完整表达式，所以每个表达式的副作用都发生在对下一个表达式求值之前**。

for 循环的功能
+ 使循环更新等差或等比增长
+ 自定义表达式控制循环更新
+ 用“字符计数”代替数字计数
+ 可以省略一个或多个表达式，==分号不可省略==
	``` C
	// 字符计数
	char ch = 'a;
	for (; ch <= 'z'; ch++)
	    printf("The ASCII value for %c is %d.\n", ch, ch);

	// 自定义初始化表达式
	int num=0;
	for (printf("Keep entering numbers!\n"); num != 6;)
		scanf("%d", &num);
	```

## do while 循环

do while 循环：出口条件循环（exit-condition loop），即在循环的每次迭代之后检查测试条件，这保证了至少执行循环体中的内容一次。
> 出口条件循环适用于那些至少要迭代一次的循环。

``` C
do
	statement
while(expression)
```


## 逗号运算符

``` C
int i, times;
for (i = 1, times = 2; i <= 10; i++)
    printf("%-2d\n", i * times);
```
逗号运算符扩展了for 循环的灵活性，以便在循环头中包含更多的表达式。
1. ==被逗号分割的表达式从左往右求值==
> 逗号是一个序列点，保证的左侧副作用在执行右侧前发生
2. ==整个逗号表达式的值是右侧的值==

``` C
x = (y = 3, (z = ++y + 2) + 5);
// y = 3
// x = ++y + 2
// x = 11

price = 249, 500;
// 等价 houseprice = 249; 500;
price = (249, 500);
// 等价 249; price = 500;
```

## 数组简介

数组（array）：按顺序存储的一系列类型相同的值，通过下标（subscript）、索引（index）或偏移量（offset）访问单独的项或元素（element）。
> 下标必须是从0开始的整数
> C 编译器不会检查数组下标是否越界

数组的类型可以是任意数据类型
> ==如char 数组末尾是空字符\0，则该数组构成了一个字符串==
``` C
int nums[20];
char names[20];
long big[500];
```

scanf 为数组赋值的方法：`scanf(format, &array[index]);`

用`#define` 指令创建明示常量表明数组长度，可以在定义数组是更好的设置边界
``` C
#define SIZE 10

void main(void)
{
    int i, score[SIZE];
    int sum = 0;

    for (i = 0, printf("Enter %d golf scores:\n", SIZE); i < SIZE; i++) {
        scanf("%d", &score[i]); // 输入是缓冲的，所以可以直接在一行内输入10个数字
        sum += score[i];
    }

    printf("Sum of scores = %d", sum);
}
```

设置2 的前8次幂
``` C
int const c_len = 8;
int nums[c_len];
int i;

nums[0] = 1;
for (i = 1; i < c_len; i++)
	nums[i] = nums[i - 1] * 2;

i = 0;
do {
	printf("%-4d\n", nums[i]);
	i++;
} while (i < c_len);
```

# C控制语句：分支和跳转

智能的一个方面是根据情况做出相应的响应，选择语句是开发具有智能行为程序的基础。
+ if
+ ?
+ switch

## if 语句

if 语句被称为分支语句（branching statement）或选择语句（selection statement），因为它相当于一个交叉点，程序要在两条分支中选择一条执行。
``` C
if (expression)
	statement
```

如果expression 为真（非0），则执行statement1；如果expression 为假或0，则执行else 后面的statement2。
> 在if 和else 之间只允许有一条语句（简单语句或复合语句）
``` C
if (expression)
	statement1
else
	statement2

// else 与同一层级最近的if 相匹配
if (expression)
	statement1
else if (expression1)
	statement1
else
	statement2
```

使用花括号
+ 当语句太长时，使用花括号能提高代码的可读性
+ 可防止今后在其中添加其他语句时忘记加花括号

## 逻辑运算符

逻辑运算符的优先级比关系运算符低。

在iso646.h 头文件中定义了逻辑运算符的替代写法
+ &&：and
+ ||：or
+ !：not
	``` C
	#include <iso646.h>
	printf("%d", 2 > 1 and not 2  == 0);
	```

使用圆括号可以令表达式的含义更清楚。

**C 保证逻辑表达式的求值顺序是从左往右。&& 和|| 运算符都是序列点，所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效。**

逻辑运算符优先级
1. ()
2. ==!==, ++, --
3. \* / %
4. \+ \-
5. < <= > >=
6. == !=
7. ==&&==
8. ==||==
9. = += -=……

三元运算符? `expression1 ? expression2 : expression3`
> expr1 为真则取expr2 的值，否则取expr3 的值

``` C
int x;
scanf("%d", &x);
printf(
	"I have %d %s.",
	x,
	x > 1 ? "pens" : "pen"
);
```

## 循环辅助：continue 和break

3种 循环都可以使用continue 和break
+ continue：跳过对应循环中本次迭代剩余部分，进入下一次迭代
+ break：终止对应循环

使用continue 或break 的好处是减少语句的缩进，使代码更简洁。如果反而让代码更复杂，则改为其他方式。
``` C
// 不灵活的写法
if (ch == '\t')
	continue;
putchar(ch);

// 更流利的写法
if (ch != '\t')
	putchar(ch);
```

**避免使用循环头后紧跟分号（空语句）的写法**
``` C
while (getchar() != '\n');  // 可读性极低的写法

while (getchar() != '\n')  // 推荐的写法
	continue
```

求最小值时先假定是能取到的最大值，最大值同理。
> 每次循环都能得到小于或等于当前假定的数，一旦满足小于就开始和这个新的数比较。以此类推，直到循环结束得到真实的最小值。
``` C
const float MIN = 0.f;
const float MAX = 100.f;
float score;
float total = 0.f;
int n = 0;
float min = MAX;
float max = MIN;

printf("Enter the first score: ");
while (scanf("%f", &score) == 1) {
	if (score < MIN || score > MAX) {
		printf("%.1f is an invalid value. Try again: ", score);
		continue;
	}
	printf("Accepting %.1f:\n", score);
	min = (score < min) ? score : min;  // ?运算符作比较和赋值，简化代码
	max = (score > max) ? score : max;
	total += score;
	n++;
}
if (n > 0) {
	printf("Average of %d scores is %.1f.\n", n, total / n);
	printf("Low = %.1f, high = %.1f\n", min, max);
}
else
	printf("No valid scores were entred.\n");
```

## 多重选择：switch 和break

``` C
switch (整型表达式){
	case 常量1:
		[语句]
		[break]
	case 常量2:
		[语句]
		[break]
	[default :]
		[语句]
}
```
+ switch 和case 传递的都必须是==整型==（包括char）
+ switch 可以是变量、常量或表达式
+ ==case 必须是常量或常量表达式==

无匹配项时会执行default 中的语句，无default 直接跳出switch。

break 可用于switch。**若case 中无break ，则进入该case 后程序会继续执行switch 剩余的部分**，否则会跳出switch。
> default 语句块不一定要放在最后，当位置不在最后且无break 语句时，特性将同普通case 语句一致——进入后继续执行下面的case 语句。

==switch 无法单独使用continue==，当switch 包含在循环内，可在case 中出现隶属于循环的continue。

使用switch 通常比if 运行更快，生成的代码更少。

## goto 语句

Kernighan 和Ritchie 提到goto语句“易被滥用”，并建议“谨慎使用，或者根本不用”。

goto语句有两部分：goto和标签名。标签的命名遵循变量命名规则。
``` C
goto tag_name;
tagname: statement;
```

goto 标签所在位置的代码
+ 用goto 跳转至此会运行
+ **顺序执行至此也会运行**

# 字符输入/输出和输入验证

## 单字符I/O：getchar() 和putchar()

**getchar() 函数不带任何参数，它从输入队列中返回下一个字符；putchar() 函数打印参数。
这些函数只处理字符，所以==它们比更通用的scanf() 和printf() 函数更快、更简洁==。**
> getchar()和putchar()不需要转换说明，因为它们只处理字符
> 通常定义在stdio.h头文件中（通常是预处理宏，而不是真正的函数）
``` C
char a = getchar();
putchar(a);

char ch;
for (ch = getchar(); ch != '\n'; ch = getchar()) {
    if (ch == ' ')
        putchar(ch);
    else
        putchar(ch + 1);
}
putchar(ch);
// > CALL ME HAL.
// > DBMM NF IBM/
```

## 缓冲区

无缓冲：用户输入的字符立即显示在屏幕上（回显）

为什么要有缓冲区（buffer）
1. 若干字符积攒成块传输更高效
2. 留给用户修正错误的机会

缓冲区
+ 完全缓冲I/O：缓冲区被填满时才刷新，常见于文件输入
+ 行缓冲I/O：出现换行符时刷新，常见于键盘输入

最初K&R 把输入是否缓存的决定权交给了编译器，后续ANSI C 和C 标准都规定输入是缓冲的。

在conio.h 中提供了兼容许多IBM PC 兼容机的特殊函数原型
+ getche()：回显无缓冲输入
+ getch()：无回显缓冲输入

UNIX 系统控制缓冲方式（受限于系统内部设置，可能不生效）
+ 用ioctl() 指定待输入的类型
+ 用getchar() 执行相应操作
+ 用setbuf() 和setvbuf() 控制缓冲

# 函数

## 函数

函数（function）是完成特定任务的独立程序代码单元。
1. 避免重复书写
2. 提高了模块化

模块化（modularity）：把程序划分为一些独立的单元，每个单元执行一个任务
+ 提高程序可读性
+ 方便后续的维护

``` C
int f(int, int); // 可以省略形参名
int f(int a, int b); // 声明的形参名可与定义的不同

int f(int n0, int n1) { // 函数定义的花括号不可省略
	return n0 + n1;
}
```


函数定义与声明
+ 函数签名（signature）：函数原型（function prototype）告诉编译器函数的类型
> 函数签名放在main 内外均可，但必须先声明后使用
> 可以省略变量名，但不能省略类型
+ 函数定义（function definition）：明确地指定了函数要做什么

函数调用（function call）：表明在此处执行函数

局部变量（local variable）：函数中的变量，属该函数私有

形参与实参
+ **形式参数（formal parameter）：被调函数（called function）中的变量，也是局部变量，属被调函数私有。每次调用函数，就会给这些变量赋值（从主调函数中拷贝而来）。**
+ **实际参数（actual parameter）：主调函数（calling function）赋给被调函数的具体值。**

如果没有声明函数的类型，旧版编译器会假定为int。**C99标准不再支持int 类型函数的这种假定设置。**

主调函数把它的参数存储在被称为栈（stack）的临时存储区，被调函数从栈中读取这些参数。
主调函数根据函数调用中的实际参数决定传递的类型，而被调函数根据它的形式参数读取值。

每个C函数都有自己的变量，这样做可以防止原始变量被被调函数中的副作用意外修改。

对于参数的类型和数量都不固定的情况，ANSI C允许使用部分原型。
``` C
int printf(cont char *, …);
```

## 递归

递归（recursion）：函数调用自己

可以使用循环的地方通常都可以使用递归。每次递归都会创建一组变量放在栈中，其次每次函数调用都要花费一定时间，所以递归较慢。

``` C
void up_and_down(int n) {
	printf("Level %d: n location %p\n", n, &n);
	if (n < 4)
		up_and_down(n + 1);
	printf("LEVEL %d: n location %p\n", n, &n);
}

void main() {
	up_and_down(1);
}
```
递归基本原理
+ 每级函数调用都有自己的变量
+ 函数调用会逐级返回
+ 递归函数中==递归前的语句顺序执行==
+ 递归函数中==递归后的语句逆向执行==

特殊递归
+ 尾递归（tail recursion）：递归调用置于函数的末尾
+ 双递归（double recursion）：每一级递归都要调用自己两次
> 因为每次递归都会创建私有变量，所以多递归会使变量呈指数级增长，消耗过多内存

所有的C 函数皆平等，每个函数都可以调用其他函数，或被其他函数调用。
> 包括main()，当man() 与其他函数放在一起时，最开始执行的是main()，main() 虽可以被自己调用，但很少这样做。

## 更改主调函数中的变量

一元& 运算符给出变量的存储地址，%p是输出地址的转换说明。
> PC 地址通常用十六进制形式表示

``` C
int n = 2;
printf("n = %d and &n = %p\n", n, &n);
```

指针（pointer）变量的值是地址。
指针变量声明方法同普通变量，区别是在变量前加\*，\*和名称之间的空格可有可无。
``` C
int *pi;
char *name0, *name1;
```

解引用运算符\*（dereferencing operator）：给出存储在指针指向地址上的值，因此也被称为间接运算符（indirection operator）。
``` C
int num = *pnum;
```

被描述为指向某类型的指针。地址是由一个无符号整数表示，但不支持整数相关操作，反之亦然（指针实际上是一个单独的类型）。

利用指针修改主调函数中的值
> scanf() 便是通过传递遍历的地址实现修改变量的操作
``` C
void interchange(int *x, int *y){
	int temp;
	temp = *x;
	// *x = *y 并不是修改指针x 本身（它存储的地址），而是修改指针x 所指向地址中存储的值（解引用操作）。
	*x = *y;
	*y = temp;
}

void mina(){
	int n0 = 1;
	int n1 = 2;
	interchange(&n0, &n1);
}
```

变量属性
+ 编程：名称，值
+ 编译：地址，值
> 地址时变量在计算机内部的名称

& \* 相当于是一对互逆运算：
+ **普遍变量把值作为基本量，通过& 得到地址**
+ **指针变量把地址作为基本量，通过\* 得到值**

& 虽然可以用于打印地址，但& \* 主要用途是操纵地址和地址上的内容。

# 数组和指针

## 数组

**只存储单个值的变量有时也称为标量变量（scalar variable）。**

变量名后的方括号表明是数组，方括号中的数字表明元素个数。使用下标或索引访问数组，编号从0开始。
> 声明时未使用static 为自动存储类别，意味着数组在函数内部声明
``` C
float candy[365];
char code[12];
int nums[10 / 5]; // 被强制转换为整型常量
```

使用花括号初始化数组，值之间用逗号分隔。
``` C
int powers[2] = {1, 2};
```
+ 初始化项过少时：剩余的元素会被赋予内存中随机值（**好的编译器会在初始化项数不足或未初始化时赋予“默认值”**）
+ 初始化项过多时：编译器会报错（**可以省略方括号中的数字，让编译器自动匹配**）
+ ==初始化了的数组才有赋予默认值的情况，否则同普通变量一样未初始化是内存中随机值==

同标量变量一样，通过const 声明可创建只读数组。

==C 不允许把数组作为一个单元赋给另一个数组，除初始化以外也不允许使用花括号赋值。==

==通过 sizeof 计算数组元素个数==
``` C
const int days[] = {28, 29, 30, 31}
// sizeof days 得到整个数组的大小，sizeof days[i] 得到数组中单个元素的大小
int len = sizeof days / sizeof days[0];
```

在之前只能用常量设置数组大小，C99 引入了变长数组（variable length array, VLA）。
> C11 把VLA 特性设定为而可选

## 多维数组

二维数组：主数组（master arry）的元素同样是数组
``` C
float rain[5][12];
// 第一个方括号声明最外层包含多少个数组
// 第二个方括号声明每个数组含多少个元素
```

二维数组初始化，一维数组初始化项数不匹配原则适用于多维数组
``` C
int nums[3][2] = {{0, 1}, {2, 3}, {4, 5}};
int ns[3][2] = {0, 1, 2};
```
+ 使用嵌套的花括号声明
+ 只使用最外层的花括号，**项数不足时按照行顺序优先填充**
> 在计算机内部，（多维）数组是按顺序存储的

多维数组：即数组不停的嵌套数组，实现数据的升维，如：
+ 一维数组：“行”
+ 二维数组：“表”
+ 三维数组：存储表的数组

利用scanf 为二维数组赋值
``` C
int nums[ROWS][COLS];
int i, j;
i = j = 0;

while (scanf("%d", &nums[i][j]) == 1) {
	j++;
	// 列遍历完毕，移动到下一行
	if (j >= COLS) {
		i++;
		j = 0;
	}
	// 行遍历完毕，退出循环
	if (i >= ROWS)
		break;
}
```

## 指针和数组

指针提供一种以符号形式使用地址的方法。

==数组名是数组首元素的地址。==
``` C
nums == &nums[0];
```

==指针的值+n，是移动到下n 个元素的地址（右移，递增所指向类型的大小）==
> 地址按字节编址：short 占2个字节，double 占8个字节
> 因此声明指针时需要指明类型：不但要知道地址，还要知道元素的类型以及占用的字节
``` C
#include <stdio.h>
#define SIZE 4

void main() {
	short dates[SIZE]; short* pti;
	double bills[SIZE]; double* ptf;
	short i;
	pti = dates;
	ptf = bills;
	printf("%23s %15s\n", "short", "double");
	for (i = 0; i < SIZE; i++)
		printf("pointers + %d: %10p %10p\n", i, pti + i, ptf + i);
}
```

数组和指针的关系十分密切
``` C
nums + i == &nums[i] //相同的地址
*(nums + i) == nums[i] //相同的值
```
+ 数组表示法
+ 指针表示法

**使用指针表示法遍历数组 `*(nums + i)`**
``` C
int nums[5] = { 0, 1, 2, 3, 4 };
for (int i = 0; i < 5; i++)
	printf("%-2d ", *(nums + i));
```

指针表示法不一定比数组表示法有优势，编译器编译这两种写法生成的代码相同。

## 函数、数组和指针

==只有在函数原型或函数定义头中，才可以用int ar[]代替int \*ar==
``` C
int sum(int *ar, int n); int sum(int *, int);
int sum(int ar[], int n); int sum(int [], int);
```

函数要处理数组必须知道何时开始、何时结束
+ 传入首地址，数组长度
+ 或传入首地址，尾地址
``` C
int sum(int* ar, int n) {
	int i;
	for (i = 1; i < n; i++)
		ar[i] += ar[i - 1];
	return ar[i - 1];
}

int sump(int* start, int* end) {
	// 更一般的形式 (start < end) 等价py 中的切片nums[n: m]
	while (++start < end)
		*start += *(start - 1);
	return *(start - 1);
}

void main() {
	int nums[5] = { 0, 1, 2, 3, 4 };
	// printf("%d\n", sum(nums, 5));
	printf("%d", sump(nums, &nums[5]));
}
```

==函数形参中的数组指针并不是数组本身，存储的是地址，大小是8字节==
``` C
void len_ar(int* ar) {
	printf("%zd\n", sizeof ar);
}

void main() {
	int nums[5] = { 0, 1, 2, 3, 4 };
	printf("%zd\n", sizeof nums);
	len_ar(nums);
}
```

解引运算符与自增减运算符
+ **`x = *p++`：先解引用并赋值给x，再地址右移**
+ **`x = *++p`：先地址右移，再解引用并赋值给x**
+ **`x = (*p)++`：先解引用并赋值给x，再值自增**
``` C
void main() {
	int nums1[] = { 0, 10, 20 };
	int nums2[] = { 300, 400, 500 };
	int *p1 = nums1;
	int *p2 = &nums1[1];
	int* p3 = &nums2[2];
	printf(
		"*p1++ = %d, *++p2 = %d, (*p3)++ = %d\n",
		*p1++, *++p2, (*p3)++
	);
	printf(
		"*p1 = %d, *p2 = %d, *p3 = %d\n",
		*p1, *p2, *p3
	);
}
```

==数组的数组表示法和指针表示法虽等价，但只有指针变量才能使用自增减运算。==
> 数组名是地址常量不允许修改

指针支持的运算
+ `p = nums`：赋值
+ `*p`：解引用
+ `p`：存储的地址
+ `&p`：本身的地址
+ `p++; p--;`：自增自减
+ `p - n; p + n;`：左移右移
+ `p0 == p1; p0 < p1;` 比较指针

指针的减法运算
+ **指针 - 指针：相当于计算两个指针间的距离，计算结果是整数**
+ **指针 - 整数：相当于将指针向左移n 个距离，计算结果是指针**

==不可解引用未初始化的指针==
> **创建指针时，系统只分配了存储指针本身的内存，未分配存储数据的内存**
``` C
// 将导致程序崩溃
int* p;
*p = 1;
```

## 保护数组中的数据

函数传参
+ 要修改基本类型时传递指针，否则传递数值
+ 数组必须传递指针，更高效
> 若按值传递数组，则必须分配额外的空间来拷贝生成副本

修改数组
``` C
void alter_arr(int* start, int* end) {
	int* first = start;
	while (start < end) {
		(*start)++;
		start++;
	}
	while (first < end)
		printf("%-4d ", *first++);
	printf("\n");
}

void main() {
	int nums[] = { 1, 10, 20, 30, 40, 50};
	alter_arr(nums, nums + 6);
	for (int i = 0; i < 6; i++) {
		printf("%-4d ", nums[i]);
	}
}
```

函数会将声明为const 的形参数组视为不可更改的常量
``` C
void func(const int ar[]);
```

const 指针
+ const 指针：是否为const 变量都可接收
+ ==非const 指针：只能接受非const 的变量==

const 出现位置
+ ==在 \* 后，锁址==：`int* const p`
+ ==在 \* 前，锁值==：`const int* p` $\Leftrightarrow$ `int const * p`
+ ==同时出现，双锁==：`const int* const p`
``` C
int nums[] = { 1, 2, 3 };
const int* lock_value = nums;
int* const lock_address = nums;
const int* const lock_2 = nums;

*lock_value = 10; // 不允许
lock_value = &nums[1]; // 允许

*lock_address = 10; // 允许
lock_address = &nums[1]; // 不允许

*lock_2 = 10; // 不允许
lock_2 = &nums[1]; // 不允许
```

## 指针和多维数组

**有几个维度便访问几次**
> 2维数组第一次访问得到行，第二次访问根据列得到行列交叉处对应的分量
 
`nums[R][C]` 是R 行C 列的二维数组
+ 首地址指向的是第1行：`**nums == *nums[0] == nums[0][0]`
+ 移动指针相当于在行上移动：`nums + i == nums[i]`

双重间接（double indirection）：地址的地址或指针的指针

声明一个指向二维数组的指针
> **==\[\] 优先级高于\*==，不加括号会使`p` 成为数组，类型是`int *`**
``` C
int (* p)[cols];  // 指针，指向长度为cols 的整型数组
int * p[cols]; // 数组，其中包含cols 个指向整型的指针
```

同一维数组一样，多维数组在函数声明或定义中可以省略最左边方括号中的长度
> **编译器会把数组表示法转换成指针表示法**
> **对于N 维数组nums，例如nums[1] 会转换成nums + 1，编译器需要知道最外层移动1行，要跨过多少字节，因此只能省略最左边方括号的值。**
``` C
// 第一个方括号表明是指针，因此类似nums[][2] 等价(*nums)[2]
int sum2(int nums[][2], int rows);
int sum2(int (*nums)[2], int rows);

int sum4d(int nums[][12][20][30], int rows);
int sum4d(int (*nums)[12][20][30]);

// 声明并初始化时也只能省略最左边的方括号，例如：
int nums[][5] = { {1, 2, 3, 4, 5}, {10, 20, 30, 40, 50} };
```

二维数组函数的定义和调用
``` C
int sum2(int(*ar)[5], int rows) {
	int total = 0;
	for (int r = 0; r < rows; r++)
		for (int c = 0; c < 5; c++)
			total += ar[r][c];
	return total;
}

void main() {
	int nums[][5] = { {1, 2, 3, 4, 5}, {10, 20, 30, 40, 50} };
	int result = sum2(nums, sizeof nums / sizeof nums[0]);
	printf("%d\n", result);
}
```

二维数组默认值与指针移动
+ `torf[2][2] = { 12, 14, 16 }; *ptr = torf[0];`
> 内部没有花括号区分，会被顺序填充，即`torf[1][1] `没有初始值，成为默认值0
	+ `* ptr：torf[0][0] = 12`
	+ `* (ptr + 2)：torf[1][0] = 16`
+ `fort[2][2] = { {12}, {14, 16} }; * ptr = fort[0]`
> 由于有花括号强制区分，所以`fort[0][1]` 未被赋值是默认值0
	+ `* ptr：fort[0][0] = 12`
	+ `* (ptr + 2)：fort[1][0] = 14`
``` C
int torf[2][2] = { 12, 14, 16 };
int fort[2][2] = { {12}, {14, 16} };
int* ptr;

ptr = torf[0];
printf(
	"*ptr = %d, *(ptr + 2) = %d, torf[1][0] = %d\n", 
	*ptr, *(ptr + 2), torf[1][0]
);

ptr = fort[0];
printf(
	"*ptr = %d, *(ptr + 2) = %d, fort[1][1] = %d\n",
	*ptr, *(ptr + 2), fort[1][0]
);
```

## 变长数组（VLA）

**使用多维数组相关变量或指针时列数常采用`#define` 来定义，因为C 规定常规方法下数组的维数必须是常量。**

C99 新增了变长数组（variable-length array, VLA），允许变量表示数组的维度，但是完全支持这一特性的编译器不多。

C99/C11 标准规定可以省略原型中的形参名，此时多维指针需要用星号替代。
``` C
int sum2d(int, int, ar[*][*]); // 数组指针维数省略时以星号代替
int sum2d(int rows, int cols, int arr[rows][cols]);
```

边长数组允许动态内存分配，即程序可以在运行时指定数组大小。
> 普通C 数组都是静态内存分配，即在编译时确定数组大小。由于数组大小是常量，所以编译器在编译时就能知晓。

## 复合字面量

在C99 标准以前，对于带数组形参的函数，可以传递数组，但是没有等价的数组常量。C99 新增了复合字面量（compound literal）。
1. 同数组初始化类似，可以省略大小
2. 复合字面量变量名是首地址，因此可以传递给指针
3. 复合字面量作为实参直接传递给函数是典型的用法
``` C
(int []){10, 20}  // 复合字面量
```


# 字符串和字符串函数

## 表示字符串和字符串I/O

字符串是以空字符（\0）结尾的char类型数组。

puts() 和printf() 同属于stdio.h 系列的输入输出函数。**puts() 仅显示字符串，而且会在末尾自动输出换行符。**
``` C
char const *p = "Hello, world!";
char pa[] = "It is not only tiresome but boring.";
puts(p);
puts(&pa[3]);
```

字符串定义方法
+ 字符串常量（string constant）：也叫字符串字面量（string literal）
+ char 类型数组
+ 指向char 的指针
> 需要定义const 指针才能接收字符串常量，数组不是必须

==使用数组的花括号形式初始化字符串时，若结尾没有没有\\0 将会被视为字符数组。字符串字面量末尾会自动添加\0。==
``` C
char name_str[] = { '1', '2', '3', '\0'};
puts(name_str); // 末尾有\0，被视为字符串，能正常输出

char name_arr[] = { '1', '2', '3' };
puts(name_arr); // 末尾没有\0，是字符数组，不能正常输出
```

从ANSI C 标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔，C 会将其视为串联起来的字符串字面量。
``` C
char const* p = "Hello, " "and how are you"
	" today!";
puts(p);
```

==字符数组名是该数组首元素地址==

==字符串属于静态存储类别（static storage class）==：**字符串只会被存储一次，即使多次调用。**

==初始化数组把静态存储区（static memory）的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。==

**编译器可以把多次使用的相同字面量存储在一处（单词副本表示法）或多处**
> 如果编译器使用单次副本表示法，且允许指针变量修改所执行的字符串常量，将影响所有出现了该字符串的代码
> %%数组不会有此类问题——数组存储的是副本%%

==数组名是（地址）常量，而指针名是变量==
+ 数组和指针表示法都可以用下标 `p[i]`
+ 数组和指针表示法都能移动指针 `*(p + i)`
+ **只有指针表示法允许递增（减）操作 `*(p++)`**

指针字符串数组效率更高
+ 指针字符串数组：不规则数组，不可修改。存储了指向初始化字符串常量的指针
+ 字符串数组：规则数组，可以修改。存储的是初始化字符串字面量的副本

## 字符串输入

**要把一个字符串读入程序，首先必须预留存储该字符串的空间**
> 最简单的方法是，在声明时显式指明数组的大小 `char name[81];`
``` C
char* name;
// Exception: The variable 'name' is being used without being initialized.
scanf("%s", name);
```

gets() 函读取整行输入，直至遇到换行符时停止读取（==会丢弃换行符==），并在末尾添加空字符使其成为字符串。
``` C
char words[100];
gets(words);
puts(words);
```

==C11 从标准中废除了gets()==，但大部分编译器仍出于兼容的目的而支持该函数。
> **gets() 只有数组首地址，不知道数组长度，不会检查是否溢出。**

fgets() 通过参数读入字符数的最大数量来解决gets() 溢出问题
> 和fgets() 相对应的输出函数是fputs()
``` C
fgets(words, max_length, stdin);
fputs(words, stdout);
```
+ stdin：标准输入
+ stdout：标准输出

fgets() 读取停止条件
+ 长度超过限制
+ 或遇到换行符（==不会丢弃换行符==）
> ==puts() 会在末尾添加换行符，而fputs() 不会。==
> 读取换行符的好处是可以利用此来判断是否读取了一整行

fgets() 返回指向char 的指针，如果读到文件结尾则返回空指针（null pointer）
> **C 语义中用宏NULL 来代替空指针，空指针保证不会指向有效数据**

遇到Return 键
+ 输入都被存储在缓冲区，按下Return 键后会把整行输入发送给fgets()
	+ 超出容器长度的部分会留在缓冲区，待下一次读取
+ fputs() 把输出的字符发送给另一个缓冲区，发送换行符时将其中的内容发送至屏幕

用fputs() 读取并截断每次输入时超出数组长度的部分
> 不抛弃缓冲区余下的字符，可能导致下次读取的是上次遗留的额外输入，从而导致程序不能按预期执行
``` C
#define LEN 10

char words[LEN];
int i;

puts("Enter strings (empty line to quit):");
while (fgets(words, LEN, stdin) != NULL && words[0] != '\n') {
	i = 0;
	while (words[i] != '\n' && words[i] != '\0')
		i++;
	// 将换行符替换为空字符
	if (words[i] == '\n')
		words[i] = '\0';
	else
		// 读取并抛弃将缓冲区内多余的字符
		while (getchar() != '\n')
			continue;
	puts(words);
}

puts("Done.");
```

空字符'\0' 与空指针（NULL），两者都可以用数值0 来表示
+ 空字符：字符，占1字节
+ 空指针：指针，通常占4字节

gets_s() 与fgets() 的区别
+ gets_s() 只从标准输入中读取数据，所以不需要第3个参数
+ ==gets_s() 不会读取换行符== %%因此和gets() 几乎一样%%
+ 当gets_s() 读到最大字符数都没有读到换行符
	+ 目标数组中的首字符设置为空字符
	+ **读取并丢弃随后的输入直至换行符或文件结尾**
	+ 返回空指针
	+ 调用依赖实现的“处理函数”（可能会中止或退出程序）

当输入溢出时
+ gets() 不保留换行符。会擦写现有数据，存在安全隐患
+ fgets() 保留换行符。不会自主丢弃额外输入
+ gets_s() 不保留换行符，安全性高，会丢弃额外输入，需要编写处理函数
> 鉴于gets_s() 的不灵活性，其只作为可选扩展，fgets() 通常为最佳选择

封装fgets() ，实现不读取换行符，并且丢去缓冲区中溢出的输入
#s_gets
``` C
#define LEN 10

char* s_gets(char* st, int n) {
    char* ret_val;
    int i = 0;
    ret_val = fgets(st, n, stdin);
    if (ret_val) {
        while (st[i] != '\n' && st[i] != '\0')
            i++;
        if (st[i] == '\n')
            st[i] = '\0';
        else {
            while (getchar() != '\n')
                continue;
        }
    }
    return ret_val;
}

void main(void)
{
    char words[LEN];
    puts("Enter strings (empty line to quit):");
    while (better_gets(words, LEN) != NULL && words[0] != '\0') {
        puts(words);
    }
    puts("Done.");
}
```

scanf() 更像是”获取单词“函数，从第1个非空白字符开始读取，直到遇到下1个空白字符停止（会丢弃空白字符），或读到指定长度（==不会抛弃缓冲区中额外的字符==）。

## 字符串输出

==用双引号括起来的内容是字符串常量，且被视为该字符串的地址。存储字符串的数组名也被看作是地址。==
``` C
char str1[80] = "An array was initialized to me.";
const char * str2 = "A pointer was initialized to me.";
puts(&str1[5]);  // ray was initialized to me.
puts(str2 + 4);  // inter was initialized to me.
```

==puts() 遇到空字符时停止输出==
> 当被输出对象缺少空字符'\0' 时，会导致输出”溢出“（编译器会在内存中不停读取直到遇到空字符）

输入、输出函数的换行符处理策略刚好一一配套
+ puts() 添加换行符，gets() 抛弃换行符
+ fputs() 不添加换行符，fgets() 保留换行符
> fputs() 是puts() 针对文件定制的版本

printf() 在形式上比puts() 更复杂，且执行世界更长，字符串末尾也不会自主加上换行符。但printf() 打印多个字符更简单，且可以格式化不同的数据类型。

## 自定义输入/输出函数

完全可以在getchar() 和putchar() 的基础上自定义所需的函数。

利用putchar() 实现puts() 功能，且不换行
``` C
// 不会改变传入的字符串，所以形参使用了const 限定符
void put1(const char* string) {
	// 每个字符串都以空字符结尾，所以在遇到空字符时停止循环处理即可
    while (*string != '\0')
	    // 从右向左运算，后缀所以先取值，再移动指针
        putchar(*string++);
}
```
> **当string 指向空字符时，`*string` 的值是0，因此写法可以简化（常见写法）为：`while (*string)`**

利用putchar() 实现puts() 功能，不换行且返回字符数
``` C
int put2(const char* string) {
    int count = 0;
    while (*string) {
        putchar(*string++);
        count++;
    }
    return count;
}

void main(void)
{
    const char* words = "Hello World!";
    // printf() 要打印put2() 的返回值，所以必须先执行put2()
    printf("\nI count %d characters.", put2(words));
}
```

形参用指针表示法`const char *string`可以提醒用户：实参不一定是数组，可以是数组名、用双引号括起来的字符串，或声明为`char *` 类型的变量。

## 字符串函数

ANSI C 吧字符串函数的原型放在string.h 中，最常用的有strlen()、strcat()、strcmp()、strncmp()、strcpy() 和strncpy()。另外还有存放在stdio.h 的sprintf()。

strlen() 用于统计字符串的长度（以`\0` 为结束标记，长度不包含`\0`）
``` C
void fit(char* string, unsigned int size) {
    if (strlen(string) > size)
        string[size] = '\0';
}


void main()
{
    char msg[] = "Things should be as simple as possible,"
        " but not simpler.";
    puts(msg);
    printf("before: %d\n", strlen(msg));

    fit(msg, 38);
    puts(msg);
    printf("after: %d\n", strlen(msg));

    puts("Let's look at some more of the string.");
    puts(msg + 39);
```

**strcat() 用于拼接字符串，将第2个字符串的备份附加在第1个字符串末尾**
``` C
char flower[80];
char addon[] = "s smell like old shoes.";

puts("What is your favourite flower?");
if (scanf("%s", flower) == 1) {
	strcat(flower, addon);
	puts(flower);
	puts(addon);
}
else
	puts("End of file encountered!");
```

==strcat() 无法检查第1个数组是否能容纳第2个字符串，会使多余字符溢出到相邻存储单元==
> C 语言废弃了gets()，因为gets() 造成的安全隐患主要来自用户；C 相信程序员，保留了strcat()，因此程序员有责任确保strcat() 的使用安全

**strncat()，该函数的第3个参数指定了最大添加字符数**
``` C
// 相当于python 中一个字符串拼接另一个切片的字符串："abc" + "def"[:1]
char p1[100] = "abc ";
char p2[] = "def";
strncat(p1, p2, 1);
```

实现strncat()
``` C
void mystrncpy(char* destiny, const char* source, int n) {
	destiny += strlen(destiny);
	int cnt = 1;
	while (*source && cnt <= n) {
		*(destiny++) = *(source++);
		cnt++;
	}
	*destiny = '\0';
}
```

**strcmp() 比较字符串是否相等**，比较结果相当于逻辑异或、或为ASCII 差值
> char 类型实际上是整型值，因此可用比较运算符来比较大小
+ 相同为0
+ 相异为非0：首个更小则为附属，否则正数
> strcmp 依次比较字符直到遇到不同字符或到第一个字符串的空字符为止。ASCII 中空字符排在第一位，所以非空比空字符大
``` C
strcmp("abc", "ab");
```

**strncmp() 相较于strcmp() 可传入第3个参数仅判断给定长度的部分**
``` C
// 等价python 切片比较字符串："abc"[:2] == "ab"[:2]
strncmp("abc", "ab", 2);
```

**strcpy() 拷贝整个字符串**
> strcpy() 传参顺序与赋值类似，即strcpy(destination, source)
> + des：应指向一个拥有足够的空间数据对象（如数组）
> + source：可指向指针、数组名或字符串常量
> + **返回类型是`char *`，返回的是源**

**strcpy() 目标不必指向数组的开始，可用于粘贴部分数组（==源中的空字符也会拷贝==）**
``` C
// 分配足够的空间
char des[100] = "qualification";
char source[] = "quackery";

// des = qquackery, ps = "quackery"
// 相当于python 中的字符串切片加拼接：'qualification'[:1] + 'quackery'
char * ps = strcpy(des[1], source);
```

 **使用strncpy() 解决strcpy() 不能检查目标数组空间是否足够的问题**
 > strncpy() 只会拷贝源中的前n 个或空字符之前的字符。==所以当前n 个字符不含空字符时，被拷贝的字符串将不包含空字符。==
``` C
strncpy(des, source, 5);  // 拷贝前5个
des[5] = '\0';  // 第6个元素设为空字符
```

**sprintf() 相当于“format()”，第1个参数为目标字符串地址，后续参数与printf() 类似**
``` C
char str[] = "That shirt cost me";
int len_s, len_f;
char f[28];

sprintf(f, "%s $%.2f.", str, 398.72);
len_s = strlen(str);
len_f = strlen(f);

printf("%d, %d", len_s, len_f);
puts(f);
```

其他字符串函数
+ `char* strchr(const char* s, int c)`：返回指向字符串中首次出现某个字符对应的指针（没有则返回空指针）
	+ `char* strrchr(const char* s, int c)`：返回末次出现位置
+ `char* strstr(const char* s1, const char* s2)`：返回字符串中首次出现某个子字符串对应的指针（没有则返回空指针）
	+ `char* strpbrk(const char* s1, const char* s2)`：**匹配子串中的任意字符**

利用strchr() 替换fgets() 读取到的换行符
#s_gets 
``` C
char* s_gets(char* st, int n) {
	char* ret_val;
	char* find;

	ret_val = fgets(st, n, stdin);
	if (ret_val) {
		find = strchr(ret_val, '\n');
		if (find)
			*find = '\0';
		else
			while (getchar() != '\n')
				continue;
	}
	return ret_val;
}
```

## ctype.h 字符函数和字符串

ctype.h 中的函数通常作为宏（macro）来实现
+ 字母
	+ ==isalnum：字母或数字==
	+ isalpha：字母
	+ islower：小写字母
	+ isupper：大写字母
	+ tolower：转换成小写
	+ toupper：转换成大写
+ 数字
	+ ==isdigit：数字==
	+ isxdigit：十六进制数字符
+ 其他字符
	+ ispunct：标点符号
	+ isspace：空白字符（空格、换行符、换页符、垂直制表符、水平制表符或其他本地定义的）
	+ isblank：标准的空白字符（空格、水平制表符或换行符）或本地指定的空白字符
	+ isgraph：除空格之外的任意可打印字符
	+ isprint：可打印字符
	+ iscntr：控制字符，如Ctrl+B

根据ANSI C中的定义，toupper() 函数只改变小写字符。但是一些很旧的C实现不会自动检查大小写，所以以前的代码通常需要检查是否为小写：
``` C
if (islower(*str))
	*str = toupper(*str)
```

## 命令行参数

命令行（command line）：在命令行环境中，用户为运行程序输入命令的行

命令行参数（command-line argument）：同一行的**附加项，以空格分隔，许多环境允许用双引号把多个单词括起来形成一个参数**。

C 程序可以读取并使用命令行参数 `int main(int argc, char *argv[])`
> C 编译器允许main() 有0个或2个参数（部分扩展允许有多个参数）
+ argc（argument count）：参数计数，命令行中的字符串数量
+ argv（argument value）：参数值，命令行字符串存储值在指针数组中
> 第一个参数值`argv[0]` 一般是文件名
``` C
/* repeat.c */

#include <stdio.h>

// char* argv[] 等价char** argv
void main(int argc, char* argv[]) {
	printf("The command line has %d arguments:\n", argc - 1);
	for (int i = 1; i < argc; i++)
		printf("%d: %s\n", i, argv[i]);
	puts("");
	scanf("%c");
}

> gcc repeat.c -o repeat
> start repeat.exe Resistance is futile
> start repeat.exe "I'm hungry" now
```

字符串转换为数值
+ 不带错误检测的转换
	+ atoi()：转换并返回字符串中开头部分的整数，否则返回0
	+ atof()：转换成double %%与atoi 类似%%
	+ atol()：转换成long %%与atoi 类似%%
+ 带错误检测的转换
	+ strtol()：转换成long，最多支持三十六进制 %%即a~z 都可用作数字%%
	+ strtoul()：转换成unsigned long，最多支持三十六进制
	+ strtod()：转换成double，**仅支持十进制**
``` C
int i = atoi("100 integer");
double f = atof(".2");
```

strtol()
+ nptr：指向待转换字符串的指针
+ endptr：字符串中数字结束地址
+ base：进制
``` C
const int LIM = 30;
char number[LIM];
char* end;
long value;

puts("Enter a number (empty line to quit):");
while (s_gets(number, LIM) && number[0] != '\0') {
	value = strtol(number, &end, 10);
	printf(
		"base 10 input, base 10 output: %ld, at %s (%d)\n",
		value, end, *end
	);
	value = strtol(number, &end, 16);
	printf(
		"base 16 input, base 16 output: %ld, stopped at %s (%d)\n",
		value, end, *end
	);
	puts("Next number:");
}

puts("Bye!\n");
```

许多实现使用itoa() 和ftoa() 分别把整数和浮点数转换成字符串。但是这两个函数并不是C标准库的成员，可以用sprintf() 函数代替它们，因为sprintf() 的兼容性更好。

# 存储类别、链接和内存管理

## 存储类别

### 存储类别

C 提供了多种不同的模型或存储类别（storage class）在内存中存储数据

被存储的每个值都占用一定的物理内存——对象（object）

声明变量会创建一个标识符（identifier），标识符可以用来指定（designate）硬件内存中的对象，当声明时进行了初始化则能额外提供存储在对象中的值。

**字符串字面量也是一个对象，由于其中的每个字符都能被访问，所以每个字符也是一个对象。**

不同的存储类别具有不同的存储期、作用域和链接
+ 用存储期（storage duration）描述对象在内存中保留了多久
+ 标识符可以访问对象，用标识符的作用域（scope）和链接（linkage）表明了程序的哪些部分可以使用它

作用域
+ 函数作用域（function scope）：仅用于goto 语句的标签
+ 文件作用域（file scope）：定义在函数的外面，从定义出到文件末尾
+ 函数原型作用域（function prototype scope）：形参，从定义处到声明结束
+ 块作用域（block scope）：定义在块中的变量，从定义处到包含该定义块的末尾
	+ 形参虽然当以在花括号内，也是块作用域
	+ C99 放宽了标准，块作用域的变量不必声明在开头

具有文件作用域的变量，可以作用于多个函数，因此也称全局变量（global variable）

编译器把源码和所有头文件都视为一个包含信息的单独文件——翻译单元（translation unit）
> 文件作用域的实际可见范围是整个翻译单元

仅有文件作用域的变量才有链接
+ **内部链接：仅能在1 个翻译单元中使用**，使用static 修饰的为内部链接 `static int x;`
+ **外部链接：可以在多个翻译单元中使用**

作用域描述标识符的可见性

存储期描述了标识符访问的对象的生存期
+ 静态存储期：在程序的执行期间一直存在
	+ 文件作用域变量
	+ static 声明的块变量
+ 线程存储期：线程变量%%\_Thread_local 声明的变量，每个线程都获得该变量的私有备份%%，从被声明时到线程结束一致存在
+ 自动存储期
	+ 块作用域变量：进入块时为其分配内存，退出时释放内存
	+ 变长数组变量：从声明处直到块的末尾
+ 动态分配存储期

| 存储类别   | 存储期 | 作用域 | 链接  | 声明方式         |
| ------ | --- | --- | --- | ------------ |
| 自动     | 自动  | 块   | 无   | 块内           |
| 寄存器    | 自动  | 块   | 无   | 块内，register  |
| 静态外部链接 | 静态  | 文件  | 外部  | 所有函数外        |
| 静态内部链接 | 静态  | 文件  | 内部  | 所有函数外，static |
| 静态无链接  | 静态  | 块   | 无   | 块内，static    |
==存储类别的选择遵循”按需知道“原则，尽量在函数内部解决该函数的任务，只共享那些需要共享的变量。==**大多数情况下使用默认的自动存储类别即可。**

所有变量一律使用外部变量，可能导致某个函数可以私下修改其他函数的变量
> 唯一例外的是 const 变量，其在初始化后就不会被修改

### 自动变量

auto 是存储类别说明符（storage-class specifier）：显示指定为自动存储类别 `auto int x;`
> auto 在C++ 中用法不同，最好不要使用

如果变量仅供该块使用，那么可以在块中就近定义，以便在靠近使用变量的地方记录其含义。另外，这样的变量只有在使用时才占用内存。

不同块中可以使用同名变量，但是这些变量是各不相同的存储在不同位置的变量

**当内层块中声明的变量与外层块中的变量同名时，内层块会隐藏外层块的定义。但是离开内层块后，外层块变量的作用域又回到了原来的作用域。**

==整个循环是它所在块的子块（sub-block），循环体是整个循环块的子块。与此类似，if语句是一个块，与其相关联的子语句是if语句的子块。==
``` C
int x = 30;
printf("x in outer block: %d at %p\n", x, &x);
{
	int x = 70;
	printf("x in inner block: %d at %p\n", x, &x);
}
printf("x in outer block: %d at %p\n", x, &x);
while (x++ < 33) {  // 外层块的x
	int x = 100;  // 循环的子块的x
	x++;  // 循环的子块的x
	printf("x in while loop: %d at %p\n", x, &x);
}
/* 外层块的x 在循环中递增了4 次，最后结果是34
	1. 30, 30++: 进入循环体
	2. 31, 31++: 进入循环体
	3. 32, 32++: 进入循环体
	4. 33, 33++: 退出循环体
*/
printf("x in outer block: %d at %p\n", x, &x);
```

==自动变量不会初始化，除非显式初始化它。==未初始化的值会是之前在该内存的任意值
> 可以用常量表达式，或非常量表达式（non-constant expression）初始化自动变量

寄存器变量申请存储在CPU的寄存器中，或者存储在最快的可用内存中
> 编译器根据寄存器或最快可用内存数量来衡量请求，或直接忽略
> %%寄存器变量存储在寄存器中，所以无法获取地址，即使编译器忽略请求%%

寄存器变量和自动变量一样都是块作用域、无链接和自动存储期。当申请寄存器失败时，则直接成为普通的自动变量。

register 可以用在形参，能被修饰的数据类型是有限的，因为寄存器可能存储不下
``` C
register int quick;
void macho(register int n);
```

### 静态变量

**静态变量（static variable）是指变量在内存中原地不动，在程序被载入内存时已执行完毕。**
> ==静态变量也要遵循先声明后使用的原则==

局部静态变量被声明在块中只是为了告诉编译器在该块中才可见，**不能在形参中用static**
``` C
void trystat(void) {
    int fade = 1;
    static int stay = 1;  // 仅会在编译时被初始化
    printf("fade = %d and stay = %d\n", fade++, stay++);
}

void main(void)
{
    int count;
    for (count = 1; count <= 3; count++) {
        printf("Here comes iteration %d: ", count);
		trystat();
    }
}
```

外部链接的静态变量有时也被称为外部存储类别（external storage class），其变量被称为外部变量（external variable），定义性声明（defining declaration）在所有函数外面。

可用关键字extern 显示声明外部变量，在块中也可重复用extern 声明一次，块中未使用extern 关键字的同名变量会被视为局部变量而暂时隐藏相应的外部变量。
> **重复声明称为引用式声明（referencing delcaration），extern 让编译器去别处查询定义**
``` C
char Up[100];
extern int N = 10;
extern char Coal;

void main(void) {
	extern char Up[];  // 重复声明时无需指明大小
	char Coal;  // 覆盖了同名的外部变量
	printf("%d", N);
}
```

引用式声明并不会引起分配存储空间，extern 用来引用现有的外部定义，因此在函数外部或外部静态变量在其它文件进行“重复声明”是错误的
``` C
char permis = 'N';
extern char permis = 'Y';  // 错误
```

C99 和C11 标准都要求编译器识别局部标识符的前63个字符和外部标识符的前31个字符
> 外部变量名还要遵循局部环境规则，所受的限制更多

内部链接的静态变量（static variable with internal linkage）,内部变量也可以使用extern 说明符，并在块中进行引用式声明，但不会改变其链接属性
``` C
static int stayhome = 1;
void main() {
	extern int stayhome;
}
```

**在多文件中被共享的外部变量不用extern 修饰，其他变量才用extern 修饰**，==在引用其他文件的外部变量时必须先声明。==
> 否则一律使用extern 关键字无法区分引用者和被引用者（不同的编译器遵循不同的规则）

函数默认为外部函数（extern）。用static 修饰的函数为静态函数，属于特定模块私有
> **通常外部函数不用extern 声明，而专门用extern 声明定义在其他文件中的函数**
``` C
double gamma(double);  // extern double gamma(double);
static double beta(int, int);
```

## 随机函数和静态变量

## 分配内存：malloc() 和free()

动态数组（dynamic array）可以自动调整程序以适应不同的情况
+ 变长数组（C99 特性）
+ malloc() 或calloc() 动态分配内存后得到的数组

malloc（memory allocation）在运行找到合适的空闲内存块进行分配，但是不会为其赋名，将返回动态分配内存块的首字节地址。
+ malloc() 返回值需要使用强制类型转换赋值
+ malloc() 分配内存失败将返回空指针

==calloc 与malloc 类似，但是参数接受的是存储单元数量和存储单元大小，且calloc() 会将块中所有位置都初始化为0。==
``` C
double* p1 = (double*)malloc(len * sizeof(double));
double* p2 = (double*)calloc(len, sizeof(double));
```

内存数量
+ 静态内存数量在编译时固定
+ 自动变量在程序执行期间自动增加或减少
+ 动态分配的内存数量只会增加，除非用free() 释放

==free() 可以释放malloc()、calloc() 分配的内存%%，最好手动使用free() 手动释放已分配的内存%%==。有些系统会自动释放分配的内存，**分配的内存未释放或无法释放会导致内存泄漏。**

==动态分配内存的存储期从调用malloc()、calloc() 分配内存到调用free() 释放内存为止==

可以调用exit() 结束程序 `exit(EXIT_FAILURE)`
+ EXIT_SUCCESS（相当于0）表示普通的程序结束
+ EXIT_FAILURE 表示程序异常终止
> 包括UNIX、Linux 和Windows 的一些操作系统还接受一些表示其他运行错误的参数
``` C
double* ptd;
int max, number, i = 0;

puts("What is the maximum number of type double entries?");
if (scanf("%d", &max) != 1) {
	puts("Number not correctly entered -- bye.");
	exit(EXIT_FAILURE);
}

// ptd = (double*)malloc(max * sizeof(double));
ptd = (double*)calloc(max, sizeof(double));
if (ptd == NULL) {
	puts("Memory allocation failed. Goodbye.");
	exit(EXIT_FAILURE);
}

puts("Enter the vlaues (q to quit):");
while (i < max && scanf("%lf", &ptd[i]) == 1)
	++i;

printf("Here are your %d entries\n", number = i);
for (i = 0; i < number; ++i) {
	printf("%7.2f ", ptd[i]);
	if (i % 7 == 6)
		putchar('\n');
}
if (i % 7 != 0)
	putchar('\n');
puts("Done.");
free(ptd);
```

动态创建二维数组
``` C
int n = 5;
int (* p)[6] = (int (*)[6])malloc(n * 6 * sizeof(int));
```

动态创建执行指针的二维数组
``` C
#define LEN 50

void main() {
	int size, i;
	char** p;

	fputs("How many words do you wish to enter? ", stdout);
	if (scanf("%d", &size) != 1)
		return;

	p = (char **)malloc(sizeof(char) * size * LEN);
	i = 0;
	while (i < size) {
		char* w = (char*)malloc(sizeof(char) * LEN);
		if (scanf("%s", w) == 1) {
			p[i] = w;
			i++;
		}
	}

	for (i = 0; i < size; i++)
		puts(*(p + i));
	free(p);
}
```

==程序把静态对象、自动对象和动态分配的对象存储在不同的区域==
+ 静态存储类别：所用内存在编译时确定，程序执行时创建，结束时销毁
+ 自动存储类别：程序进入块时存在，离开时消失。**自动变量按顺序放入栈中**
+ 动态分配类别：由程序员管理内存的销毁，**动态内存被称为内存堆或自由内存，比较支离破碎，通常比使用栈慢**

## ANSCI C 类型限定符
+ 限定类型
	+ 恒常性（constancy）
	+ 易变性（volatility）
+ 限定符
	+ **restrict：用于提高编译器优化**
	+ \_Atomic

C99 为类型限定符增加了幂等的属性（idempotent）
> 可以在同一条声明中多次使用同一限定符（多余的会被忽略）
``` C
const const const int n = 6;  // const int n = 6;
typedef const int zip;
const zip q = 8;  // const int q = 8;
```

在文件间共享const 数据的方法
+ 使用extern 进行引用式声明
+ 使用#include 来导入头文件：不用额外区分定义式声明和引用式声明，但数据是重复的
> 头文件方法必须使用static 声明全局const 变量，否则将导致每个文件中都有一个相同标识符的定义式声明

volatile 告知计算机，代理（不是变量所在的程序）可以改变该变量的值。通常被用于硬件地址以及在其他程序或同时运行的线程中共享数据。

当编译器发现多次使用某一变量而未作修改时，会将变量存储在寄存器中——高速缓存
> 在没有volatile 时编译器不确定变量是否会被修改（会被修改则不能存储在寄存器中），因此编译器不会进行高速缓存。

**可以在声明中同时使用const 和volatile，顺序不重要**
``` C
volatile const int loc;
const volatile int * ploc;
```

==restrict 只用用于指针，表明该指针是访问数据对象的唯一且初始的方式==
> **编译器无需担心程序能通过其他入口或方法来篡改对象，因此可以选择捷径优化计算**
``` C
int ar[10];
int * par = ar;*
int * restrict restar = (int *)malloc(10 * sizeof(int));

// 编译器可以优化成restar[n] += 8;
// 其他变量对数据进行了修改，不可以改成 par[n] += 8; 
for (int n = 0; n < 10; n++){
	par[n] += 5;
	restar[n] += 5;
	ar[n] * = 2;
	par[n] += 3;
	restar[n] += 3;
}
```

restrict 高速编译器可以自由假定一些优化方案，同时高速读者要参数要满足restrict 的要求
``` C
void * memcpy(void * restrict s1, const void * restrict s2, size_t n);
void * memmove(void * s1, const void * s2, size_t n);
```
>`s1, s2` 变量使用了restrict，两个指针都是唯一的，暗示了memcpy() 的两个位置不能重叠

C11 头文件stdatomic.h 和threads.h 提供了可选的线程管理方法
> 要通过宏函数来访问原子类型。原子类型的对象被一个线程执行时，其他线程不能访问

